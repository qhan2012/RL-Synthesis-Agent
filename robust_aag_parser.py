#!/usr/bin/env python3
"""
Robust AAG Parser for RL Synthesis Project

This module provides a robust AAG parser that handles various AAG file formats
and integrates with the AAG2GNN compatibility layer.
"""

import os
import sys
import torch
from typing import Dict, List, Optional, Tuple
import re

# Add AAG2GNN to path
sys.path.append('../run1/AAG2GNN')

try:
    from torch_geometric.data import Data
    PYTORCH_GEOMETRIC_AVAILABLE = True
except ImportError as e:
    print(f"Warning: PyTorch Geometric not available: {e}")
    PYTORCH_GEOMETRIC_AVAILABLE = False


def robust_parse_aag(file_path: str) -> Optional[Dict]:
    """
    Robustly parse an AAG file and extract the graph structure.
    
    Args:
        file_path (str): Path to the .aag file
        
    Returns:
        dict: Parsed AAG data or None if failed
    """
    try:
        with open(file_path, 'r') as f:
            lines = f.readlines()
    except FileNotFoundError:
        print(f"AAG file not found: {file_path}")
        return None
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")
        return None
    
    if not lines:
        print("Empty AAG file")
        return None
    
    # Parse header line: aag max_var num_inputs num_latches num_outputs num_and_gates
    header = lines[0].strip()
    if not header.startswith('aag'):
        print(f"Invalid AAG file: must start with 'aag', got: {header}")
        return None
    
    header_parts = header.split()
    if len(header_parts) != 6:
        print(f"Invalid AAG header format: {header}")
        return None
    
    try:
        max_var = int(header_parts[1])
        num_inputs = int(header_parts[2])
        num_latches = int(header_parts[3])
        num_outputs = int(header_parts[4])
        num_and_gates = int(header_parts[5])
    except ValueError as e:
        print(f"Invalid numeric values in AAG header: {e}")
        return None
    
    # Parse inputs
    inputs = []
    line_idx = 1
    for i in range(num_inputs):
        if line_idx >= len(lines):
            print("Unexpected end of file while parsing inputs")
            return None
        try:
            inputs.append(int(lines[line_idx].strip()))
            line_idx += 1
        except ValueError as e:
            print(f"Invalid input value at line {line_idx + 1}: {e}")
            return None
    
    # Parse latches (skip for now, but maintain line count)
    for i in range(num_latches):
        if line_idx >= len(lines):
            print("Unexpected end of file while parsing latches")
            return None
        line_idx += 1
    
    # Parse outputs
    outputs = []
    for i in range(num_outputs):
        if line_idx >= len(lines):
            print("Unexpected end of file while parsing outputs")
            return None
        try:
            outputs.append(int(lines[line_idx].strip()))
            line_idx += 1
        except ValueError as e:
            print(f"Invalid output value at line {line_idx + 1}: {e}")
            return None
    
    # Parse AND gates
    and_gates = []
    for i in range(num_and_gates):
        if line_idx >= len(lines):
            print("Unexpected end of file while parsing AND gates")
            return None
        try:
            gate_parts = lines[line_idx].strip().split()
            if len(gate_parts) != 3:
                print(f"Invalid AND gate format at line {line_idx + 1}: {lines[line_idx].strip()}")
                return None
            lhs = int(gate_parts[0])
            rhs0 = int(gate_parts[1])
            rhs1 = int(gate_parts[2])
            and_gates.append((lhs, rhs0, rhs1))
            line_idx += 1
        except ValueError as e:
            print(f"Invalid AND gate values at line {line_idx + 1}: {e}")
            return None
    
    # Skip any remaining content (comments, etc.)
    # This is more robust than the original parser
    while line_idx < len(lines):
        line = lines[line_idx].strip()
        if line.startswith('c') or line.startswith('Generated by') or line == '':
            # Valid comment or empty line, skip
            pass
        elif line:
            # Non-empty non-comment line - log but don't fail
            print(f"Warning: Unexpected content at line {line_idx + 1}: {line}")
        line_idx += 1
    
    return {
        "max_var": max_var,
        "inputs": inputs,
        "outputs": outputs,
        "and_gates": and_gates,
        "num_latches": num_latches
    }


def build_graph_from_parsed(parsed: Dict) -> Optional[Data]:
    """
    Build a PyTorch Geometric graph from parsed AAG data.
    
    Args:
        parsed (dict): Parsed AAG data
        
    Returns:
        torch_geometric.data.Data: Graph or None if failed
    """
    if not PYTORCH_GEOMETRIC_AVAILABLE:
        print("PyTorch Geometric not available")
        return None
    
    try:
        # Collect all nodes
        nodes = set()
        
        # Add input nodes
        for literal in parsed["inputs"]:
            nodes.add(literal)
        
        # Add output nodes
        for literal in parsed["outputs"]:
            nodes.add(literal)
        
        # Add AND gate nodes
        for lhs, rhs0, rhs1 in parsed["and_gates"]:
            nodes.add(lhs)
            nodes.add(rhs0)
            nodes.add(rhs1)
        
        # Create node index mapping
        node_to_idx = {node: idx for idx, node in enumerate(sorted(nodes))}
        idx_to_node = {idx: node for node, idx in node_to_idx.items()}
        
        # Build edge list
        edges = []
        edge_attrs = []
        
        # Add edges from AND gates (rhs -> lhs)
        for lhs, rhs0, rhs1 in parsed["and_gates"]:
            # Edge from rhs0 to lhs
            edges.append([node_to_idx[rhs0], node_to_idx[lhs]])
            # [is_inverted, level_diff] - level_diff is simplified as 1 for now
            edge_attrs.append([1 if rhs0 % 2 == 1 else 0, 1.0])
            
            # Edge from rhs1 to lhs
            edges.append([node_to_idx[rhs1], node_to_idx[lhs]])
            # [is_inverted, level_diff] - level_diff is simplified as 1 for now
            edge_attrs.append([1 if rhs1 % 2 == 1 else 0, 1.0])
        
        # Convert to tensors
        edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous()
        
        # Create node features
        num_nodes = len(nodes)
        node_features = torch.zeros((num_nodes, 6), dtype=torch.float)
        
        # Compute node features
        input_set = set(parsed["inputs"])
        output_set = set(parsed["outputs"])
        and_lhs_set = {lhs for lhs, _, _ in parsed["and_gates"]}
        
        # Compute fanin/fanout
        fanin = {}
        fanout = {}
        
        for lhs, rhs0, rhs1 in parsed["and_gates"]:
            # Fanin for lhs
            fanin[lhs] = fanin.get(lhs, 0) + 2  # Each AND gate has 2 inputs
            
            # Fanout for rhs0 and rhs1
            fanout[rhs0] = fanout.get(rhs0, 0) + 1
            fanout[rhs1] = fanout.get(rhs1, 0) + 1
        
        # Assign features to each node
        for idx, node in idx_to_node.items():
            # Node type features
            node_features[idx, 0] = 1.0 if node in input_set else 0.0  # is_input
            node_features[idx, 1] = 1.0 if node in output_set else 0.0  # is_output
            node_features[idx, 2] = 1.0 if node in and_lhs_set else 0.0  # is_and
            
            # Connectivity features
            node_features[idx, 3] = float(fanin.get(node, 0))  # fanin
            node_features[idx, 4] = float(fanout.get(node, 0))  # fanout
            
            # Level (simplified - just use node index for now)
            node_features[idx, 5] = float(idx)  # level
        
        # Create edge attributes
        edge_attr = torch.tensor(edge_attrs, dtype=torch.float)
        
        # Create global features for the entire graph
        global_features = torch.tensor([
            float(len(parsed["inputs"])),      # num_inputs
            float(len(parsed["outputs"])),     # num_outputs
            float(len(parsed["and_gates"])),   # num_and_gates
            float(parsed["max_var"]),          # max_var
            float(max(fanout.values()) if fanout else 0.0),  # max_fanout
            float(max(fanin.values()) if fanin else 0.0)     # max_fanin
        ], dtype=torch.float)
        
        # Create graph
        graph = Data(
            x=node_features,
            edge_index=edge_index,
            edge_attr=edge_attr,
            global_x=global_features,
            num_nodes=num_nodes
        )
        
        # Add timestep for RL compatibility
        graph.timestep = torch.tensor([0.0], dtype=torch.float)
        
        return graph
        
    except Exception as e:
        print(f"Error building graph: {e}")
        return None


def load_aag_as_gnn_graph_robust(file_path: str) -> Optional[Data]:
    """
    Robustly load an AAG file and convert it to a PyTorch Geometric graph.
    
    Args:
        file_path (str): Path to the .aag file
        
    Returns:
        torch_geometric.data.Data: Graph representation or None if failed
    """
    # Parse the AAG file
    parsed = robust_parse_aag(file_path)
    if parsed is None:
        return None
    
    # Build the graph
    graph = build_graph_from_parsed(parsed)
    return graph


def test_robust_parser():
    """Test the robust AAG parser."""
    print("🧪 Testing robust AAG parser...")
    
    # Test circuit path
    test_circuit = "testcase/EPFL/ctrl/ctrl.aag"
    
    if not os.path.exists(test_circuit):
        print(f"❌ Test circuit not found: {test_circuit}")
        return False
    
    try:
        # Test parsing
        print("1. Testing AAG parsing...")
        parsed = robust_parse_aag(test_circuit)
        if parsed is not None:
            print(f"   ✅ AAG parsed successfully")
            print(f"   Max var: {parsed['max_var']}")
            print(f"   Inputs: {len(parsed['inputs'])}")
            print(f"   Outputs: {len(parsed['outputs'])}")
            print(f"   AND gates: {len(parsed['and_gates'])}")
        else:
            print("   ❌ AAG parsing failed")
            return False
        
        # Test graph building
        print("2. Testing graph building...")
        graph = build_graph_from_parsed(parsed)
        if graph is not None:
            print(f"   ✅ Graph built successfully")
            print(f"   Nodes: {graph.num_nodes}")
            print(f"   Edges: {graph.edge_index.size(1)}")
            print(f"   Node features: {graph.x.shape}")
            print(f"   Edge features: {graph.edge_attr.shape}")
        else:
            print("   ❌ Graph building failed")
            return False
        
        # Test complete pipeline
        print("3. Testing complete pipeline...")
        graph = load_aag_as_gnn_graph_robust(test_circuit)
        if graph is not None:
            print(f"   ✅ Complete pipeline successful")
            print(f"   Graph has timestep: {hasattr(graph, 'timestep')}")
        else:
            print("   ❌ Complete pipeline failed")
            return False
        
        print("🎉 All robust parser tests passed!")
        return True
        
    except Exception as e:
        print(f"❌ Robust parser test failed: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    test_robust_parser() 